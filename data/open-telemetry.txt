Optimizing: OpenTelemetry | Next.js
Skip to content
Search documentation...
Search...
⌘K
Showcase
Docs
Blog
Analytics
Templates
Enterprise
Search documentation...
Search...
⌘K
Feedback
Learn
Menu
Using Pages Router
Features available in /pages
Getting Started
Installation
Project Structure
Building Your Application
Routing
Defining Routes
Pages and Layouts
Linking and Navigating
Route Groups
Dynamic Routes
Loading UI and Streaming
Error Handling
Parallel Routes
Intercepting Routes
Route Handlers
Middleware
Project Organization
Internationalization
Data Fetching
Fetching, Caching, and Revalidating
Server Actions and Mutations
Data Fetching Patterns and Best Practices
Rendering
Server Components
Client Components
Composition Patterns
Edge and Node.js Runtimes
Caching
Styling
CSS Modules
Tailwind CSS
CSS-in-JS
Sass
Optimizing
Images
Fonts
Scripts
Metadata
Static Assets
Lazy Loading
Analytics
OpenTelemetry
Instrumentation
Third Party Libraries
Configuring
TypeScript
ESLint
Environment Variables
Absolute Imports and Module Path Aliases
MDX
src Directory
Draft Mode
Content Security Policy
Testing
Vitest
Jest
Playwright
Cypress
Deploying
Static Exports
Upgrading
Codemods
App Router Migration
Version 14
Migrating from Vite
API Reference
Components
Font
<Image>
<Link>
<Script>
File Conventions
default.js
error.js
layout.js
loading.js
not-found.js
page.js
route.js
Route Segment Config
template.js
Metadata Files
favicon, icon, and apple-icon
manifest.json
opengraph-image and twitter-image
robots.txt
sitemap.xml
Functions
cookies
draftMode
fetch
generateImageMetadata
generateMetadata
generateSitemaps
generateStaticParams
generateViewport
headers
ImageResponse
NextRequest
NextResponse
notFound
permanentRedirect
redirect
revalidatePath
revalidateTag
unstable_cache
unstable_noStore
useParams
usePathname
useReportWebVitals
useRouter
useSearchParams
useSelectedLayoutSegment
useSelectedLayoutSegments
userAgent
next.config.js Options
appDir
assetPrefix
basePath
compress
devIndicators
distDir
env
eslint
exportPathMap
generateBuildId
generateEtags
headers
httpAgentOptions
images
incrementalCacheHandlerPath
logging
mdxRs
onDemandEntries
optimizePackageImports
output
pageExtensions
Partial Prerendering (experimental)
poweredByHeader
productionBrowserSourceMaps
reactStrictMode
redirects
rewrites
serverActions
serverComponentsExternalPackages
trailingSlash
transpilePackages
turbo
typedRoutes
typescript
urlImports
webpack
webVitalsAttribution
create-next-app
Edge Runtime
Next.js CLI
Building Your Application
Routing
Pages and Layouts
Dynamic Routes
Linking and Navigating
Custom App
Custom Document
Custom Errors
API Routes
Internationalization
Authenticating
Middleware
Rendering
Server-side Rendering (SSR)
Static Site Generation (SSG)
Automatic Static Optimization
Client-side Rendering (CSR)
Edge and Node.js Runtimes
Data Fetching
getStaticProps
getStaticPaths
Forms and Mutations
getServerSideProps
Incremental Static Regeneration
Client-side Fetching
Styling
CSS Modules
Tailwind CSS
CSS-in-JS
Sass
Optimizing
Images
Fonts
Scripts
Static Assets
Lazy Loading
Analytics
OpenTelemetry
Instrumentation
Third Party Libraries
Configuring
TypeScript
ESLint
Environment Variables
Absolute Imports and Module Path Aliases
src Directory
MDX
AMP
Babel
PostCSS
Custom Server
Draft Mode
Error Handling
Debugging
Preview Mode
Content Security Policy
Testing
Vitest
Jest
Playwright
Cypress
Deploying
Going to Production
Static Exports
Multi Zones
Continuous Integration (CI) Build Caching
Upgrading
Codemods
From Pages to App
Version 14
Version 13
Version 12
Version 11
Version 10
Version 9
API Reference
Components
Font
<Head>
<Image>
<Image> (Legacy)
<Link>
<Script>
Functions
getInitialProps
getServerSideProps
getStaticPaths
getStaticProps
NextRequest
NextResponse
useAmp
useReportWebVitals
useRouter
userAgent
next.config.js Options
assetPrefix
basePath
compress
devIndicators
distDir
env
eslint
exportPathMap
generateBuildId
generateEtags
headers
httpAgentOptions
images
onDemandEntries
output
pageExtensions
poweredByHeader
productionBrowserSourceMaps
reactStrictMode
redirects
rewrites
Runtime Config
trailingSlash
transpilePackages
turbo
typescript
urlImports
webpack
webVitalsAttribution
create-next-app
Next.js CLI
Edge Runtime
Architecture
Accessibility
Fast Refresh
Next.js Compiler
Supported Browsers
Turbopack
Community
Contribution Guide
On this page
Getting Started
Using @vercel/otel
Manual OpenTelemetry configuration
Testing your instrumentation
Deployment
Using OpenTelemetry Collector
Deploying on Vercel
Self-hosting
Custom Exporters
Custom Spans
Default Spans in Next.js
[http.method] [next.route]
render route (app) [next.route]
fetch [http.method] [http.url]
executing api route (app) [next.route]
getServerSideProps [next.route]
getStaticProps [next.route]
render route (pages) [next.route]
generateMetadata [next.page]
Edit this page on GitHub
Scroll to top
Pages Router
...
Optimizing
OpenTelemetry
OpenTelemetry
Good to know
: This feature is
experimental
, you need to explicitly opt-in by providing
experimental.instrumentationHook = true;
in your
next.config.js
.
Observability is crucial for understanding and optimizing the behavior and performance of your Next.js app.
As applications become more complex, it becomes increasingly difficult to identify and diagnose issues that may arise. By leveraging observability tools, such as logging and metrics, developers can gain insights into their application's behavior and identify areas for optimization. With observability, developers can proactively address issues before they become major problems and provide a better user experience. Therefore, it is highly recommended to use observability in your Next.js applications to improve performance, optimize resources, and enhance user experience.
We recommend using OpenTelemetry for instrumenting your apps.
It's a platform-agnostic way to instrument apps that allows you to change your observability provider without changing your code.
Read
Official OpenTelemetry docs
for more information about OpenTelemetry and how it works.
This documentation uses terms like
Span
,
Trace
or
Exporter
throughout this doc, all of which can be found in
the OpenTelemetry Observability Primer
.
Next.js supports OpenTelemetry instrumentation out of the box, which means that we already instrumented Next.js itself.
When you enable OpenTelemetry we will automatically wrap all your code like
getStaticProps
in
spans
with helpful attributes.
Good to know
: We currently support OpenTelemetry bindings only in serverless functions.
We don't provide any for
edge
or client side code.
Getting Started
OpenTelemetry is extensible but setting it up properly can be quite verbose.
That's why we prepared a package
@vercel/otel
that helps you get started quickly.
It's not extensible and you should configure OpenTelemetry manually if you need to customize your setup.
Using
@vercel/otel
To get started, you must install
@vercel/otel
:
Terminal
npm
install
@vercel/otel
Next, create a custom
instrumentation.ts
(or
.js
) file in the
root directory
of the project (or inside
src
folder if using one):
your-project/instrumentation.ts
import
{ registerOTel }
from
'@vercel/otel'
export
function
register
() {
registerOTel
(
'next-app'
)
}
Good to know
The
instrumentation
file should be in the root of your project and not inside the
app
or
pages
directory. If you're using the
src
folder, then place the file inside
src
alongside
pages
and
app
.
If you use the
pageExtensions
config option
to add a suffix, you will also need to update the
instrumentation
filename to match.
We have created a basic
with-opentelemetry
example that you can use.
Manual OpenTelemetry configuration
If our wrapper
@vercel/otel
doesn't suit your needs, you can configure OpenTelemetry manually.
Firstly you need to install OpenTelemetry packages:
Terminal
npm
install
@opentelemetry/sdk-node
@opentelemetry/resources
@opentelemetry/semantic-conventions
@opentelemetry/sdk-trace-node
@opentelemetry/exporter-trace-otlp-http
Now you can initialize
NodeSDK
in your
instrumentation.ts
.
OpenTelemetry APIs are not compatible with edge runtime, so you need to make sure that you are importing them only when
process.env.NEXT_RUNTIME === 'nodejs'
. We recommend creating a new file
instrumentation.node.ts
which you conditionally import only when using node:
instrumentation.ts
export
async
function
register
() {
if
(
process
.
env
.
NEXT_RUNTIME
===
'nodejs'
) {
await
import
(
'./instrumentation.node.ts'
)
}
}
instrumentation.node.ts
import
{ NodeSDK }
from
'@opentelemetry/sdk-node'
import
{ OTLPTraceExporter }
from
'@opentelemetry/exporter-trace-otlp-http'
import
{ Resource }
from
'@opentelemetry/resources'
import
{ SemanticResourceAttributes }
from
'@opentelemetry/semantic-conventions'
import
{ SimpleSpanProcessor }
from
'@opentelemetry/sdk-trace-node'
const
sdk
=
new
NodeSDK
({
resource
:
new
Resource
({
[
SemanticResourceAttributes
.
SERVICE_NAME
]
:
'next-app'
,
})
,
spanProcessor
:
new
SimpleSpanProcessor
(
new
OTLPTraceExporter
())
,
})
sdk
.start
()
Doing this is equivalent to using
@vercel/otel
, but it's possible to modify and extend.
For example, you could use
@opentelemetry/exporter-trace-otlp-grpc
instead of
@opentelemetry/exporter-trace-otlp-http
or you can specify more resource attributes.
Testing your instrumentation
You need an OpenTelemetry collector with a compatible backend to test OpenTelemetry traces locally.
We recommend using our
OpenTelemetry dev environment
.
If everything works well you should be able to see the root server span labeled as
GET /requested/pathname
.
All other spans from that particular trace will be nested under it.
Next.js traces more spans than are emitted by default.
To see more spans, you must set
NEXT_OTEL_VERBOSE=1
.
Deployment
Using OpenTelemetry Collector
When you are deploying with OpenTelemetry Collector, you can use
@vercel/otel
.
It will work both on Vercel and when self-hosted.
Deploying on Vercel
We made sure that OpenTelemetry works out of the box on Vercel.
Follow
Vercel documentation
to connect your project to an observability provider.
Self-hosting
Deploying to other platforms is also straightforward. You will need to spin up your own OpenTelemetry Collector to receive and process the telemetry data from your Next.js app.
To do this, follow the
OpenTelemetry Collector Getting Started guide
, which will walk you through setting up the collector and configuring it to receive data from your Next.js app.
Once you have your collector up and running, you can deploy your Next.js app to your chosen platform following their respective deployment guides.
Custom Exporters
We recommend using OpenTelemetry Collector.
If that is not possible on your platform, you can use a custom OpenTelemetry exporter with
manual OpenTelemetry configuration
Custom Spans
You can add a custom span with
OpenTelemetry APIs
.
Terminal
npm
install
@opentelemetry/api
The following example demonstrates a function that fetches GitHub stars and adds a custom
fetchGithubStars
span to track the fetch request's result:
import
{ trace }
from
'@opentelemetry/api'
export
async
function
fetchGithubStars
() {
return
await
trace
.getTracer
(
'nextjs-example'
)
.startActiveSpan
(
'fetchGithubStars'
,
async
(span)
=>
{
try
{
return
await
getValue
()
}
finally
{
span
.end
()
}
})
}
The
register
function will execute before your code runs in a new environment.
You can start creating new spans, and they should be correctly added to the exported trace.
Default Spans in Next.js
Next.js automatically instruments several spans for you to provide useful insights into your application's performance.
Attributes on spans follow
OpenTelemetry semantic conventions
. We also add some custom attributes under the
next
namespace:
next.span_name
- duplicates span name
next.span_type
- each span type has a unique identifier
next.route
- The route pattern of the request (e.g.,
/[param]/user
).
next.page
This is an internal value used by an app router.
You can think about it as a route to a special file (like
page.ts
,
layout.ts
,
loading.ts
and others)
It can be used as a unique identifier only when paired with
next.route
because
/layout
can be used to identify both
/(groupA)/layout.ts
and
/(groupB)/layout.ts
[http.method] [next.route]
next.span_type
:
BaseServer.handleRequest
This span represents the root span for each incoming request to your Next.js application. It tracks the HTTP method, route, target, and status code of the request.
Attributes:
Common HTTP attributes
http.method
http.status_code
Server HTTP attributes
http.route
http.target
next.span_name
next.span_type
next.route
render route (app) [next.route]
next.span_type
:
AppRender.getBodyResult
.
This span represents the process of rendering a route in the app router.
Attributes:
next.span_name
next.span_type
next.route
fetch [http.method] [http.url]
next.span_type
:
AppRender.fetch
This span represents the fetch request executed in your code.
Attributes:
Common HTTP attributes
http.method
Client HTTP attributes
http.url
net.peer.name
net.peer.port
(only if specified)
next.span_name
next.span_type
executing api route (app) [next.route]
next.span_type
:
AppRouteRouteHandlers.runHandler
.
This span represents the execution of an API route handler in the app router.
Attributes:
next.span_name
next.span_type
next.route
getServerSideProps [next.route]
next.span_type
:
Render.getServerSideProps
.
This span represents the execution of
getServerSideProps
for a specific route.
Attributes:
next.span_name
next.span_type
next.route
getStaticProps [next.route]
next.span_type
:
Render.getStaticProps
.
This span represents the execution of
getStaticProps
for a specific route.
Attributes:
next.span_name
next.span_type
next.route
render route (pages) [next.route]
next.span_type
:
Render.renderDocument
.
This span represents the process of rendering the document for a specific route.
Attributes:
next.span_name
next.span_type
next.route
generateMetadata [next.page]
next.span_type
:
ResolveMetadata.generateMetadata
.
This span represents the process of generating metadata for a specific page (a single route can have multiple of these spans).
Attributes:
next.span_name
next.span_type
next.page
Previous
Analytics
Next
Instrumentation
Was this helpful?
supported.
Send
Resources
Docs
Learn
Showcase
Blog
Analytics
Next.js Conf
Previews
More
Commerce
Contact Sales
GitHub
Releases
Telemetry
About
Vercel
Next.js + Vercel
Open Source Software
GitHub
Twitter
Legal
Privacy Policy
Cookie Preferences
Subscribe to our newsletter
Stay updated on new releases and features, guides, and case studies.
Subscribe
©
2023
Vercel
, Inc.